use std::env;
use std::fs;
use std::path::Path;

fn main() {
    // Get the project directory
    let project_dir = env::var("CARGO_MANIFEST_DIR").unwrap();

    // Generate build configuration
    generate_build_config(&project_dir);

    // Path to the C library source
    let src_dir = format!("{}/thirdparty/webui-c-src/src", project_dir);
    let civetweb_dir = format!("{}/civetweb", src_dir);

    // Compile the C library
    let mut build = cc::Build::new();
    build
        .include(format!("{}/thirdparty/webui-c-src/include", project_dir))
        .include(&src_dir)
        .include(&civetweb_dir)
        .warnings(false)
        .flag("-fPIC") // Position Independent Code for shared libraries
        .define("WEBUI_LOG", None) // Enable logging if needed
        .define("USE_CIVETWEB", None)
        .define("NO_SSL", None) // Disable SSL to avoid OpenSSL dependency
        .define("NO_CACHING", None) // Disable caching
        .define("USE_WEBSOCKET", None) // Enable WebSocket support
        .define("USE_IPV6", None); // Enable IPv6 support

    // Add the main webui source file
    build.file(format!("{}/webui.c", src_dir));

    // Add the civetweb source file
    build.file(format!("{}/civetweb/civetweb.c", src_dir));

    build.compile("webui-2-static");

    // Tell cargo to look for libraries in the current directory
    println!("cargo:rustc-link-search=native=./");

    // Link the compiled library
    println!("cargo:rustc-link-lib=webui-2-static");

    // Re-run if C source files change
    let webui_root = format!("{}/thirdparty/webui-c-src", project_dir);
    for entry in walkdir::WalkDir::new(&webui_root) {
        let entry = entry.unwrap();
        if entry
            .path()
            .extension()
            .map_or(false, |ext| ext == "c" || ext == "h")
        {
            println!("cargo:rerun-if-changed={}", entry.path().display());
        }
    }

    // Re-run if config file changes
    let config_paths = [
        format!("{}/app.config.toml", project_dir),
        format!("{}/config/app.config.toml", project_dir),
    ];
    for config_path in &config_paths {
        if Path::new(config_path).exists() {
            println!("cargo:rerun-if-changed={}", config_path);
        }
    }

    // Notify about post-build script
    let post_build_path = format!("{}/post-build.sh", project_dir);
    if Path::new(&post_build_path).exists() {
        println!("cargo:warning=Run './post-build.sh' after build to rename executable");
    }
}

fn generate_build_config(project_dir: &str) {
    // Try to read the config file
    let config_paths = [
        format!("{}/app.config.toml", project_dir),
        format!("{}/config/app.config.toml", project_dir),
    ];

    let mut executable_name = String::from("rustwebui-app");
    let mut package_name = String::from("rustwebui-app");

    for config_path in &config_paths {
        if let Ok(content) = fs::read_to_string(config_path) {
            // Parse the executable name from config
            if let Ok(config) = content.parse::<toml::Value>() {
                if let Some(exe_name) = config
                    .get("executable")
                    .and_then(|e| e.get("name"))
                    .and_then(|n| n.as_str())
                {
                    if !exe_name.is_empty() {
                        executable_name = exe_name.to_string();
                    }
                }
            }
            println!("Found config at: {}", config_path);
            break;
        }
    }

    // Get package name from environment
    if let Ok(name) = env::var("CARGO_PKG_NAME") {
        package_name = name;
    }

    // Generate the build config file
    let out_dir = env::var("OUT_DIR").unwrap();
    let build_config_path = format!("{}/build_config.rs", out_dir);

    let build_config = format!(
        r#"// Auto-generated build configuration
// This file is generated by build.rs

pub const PACKAGE_NAME: &str = "{}";
pub const PACKAGE_VERSION: &str = "{}";
pub const EXECUTABLE_NAME: &str = "{}";

pub fn get_executable_name() -> &'static str {{
    EXECUTABLE_NAME
}}
"#,
        package_name,
        env::var("CARGO_PKG_VERSION").unwrap_or_else(|_| "1.0.0".to_string()),
        executable_name
    );

    if let Err(e) = fs::write(&build_config_path, build_config) {
        eprintln!("Warning: Failed to write build config: {}", e);
    } else {
        println!("Generated build config at: {}", build_config_path);
    }
}
